###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        13/Apr/2017  22:11:35
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Chron\Desktop\智能车\私家车_葛峰\代码\mycar\project\mycar\app\Search.c
#    Command line =  
#        C:\Users\Chron\Desktop\智能车\私家车_葛峰\代码\mycar\project\mycar\app\Search.c
#        -D LPLD_K60 -D USE_K60DZ10 -lCN
#        C:\Users\Chron\Desktop\智能车\私家车_葛峰\代码\mycar\project\mycar\iar\FLASH\List\
#        -lB
#        C:\Users\Chron\Desktop\智能车\私家车_葛峰\代码\mycar\project\mycar\iar\FLASH\List\
#        -o
#        C:\Users\Chron\Desktop\智能车\私家车_葛峰\代码\mycar\project\mycar\iar\FLASH\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "E:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Chron\Desktop\智能车\私家车_葛峰\代码\mycar\project\mycar\iar\..\app\
#        -I
#        C:\Users\Chron\Desktop\智能车\私家车_葛峰\代码\mycar\project\mycar\iar\..\..\..\lib\CPU\
#        -I
#        C:\Users\Chron\Desktop\智能车\私家车_葛峰\代码\mycar\project\mycar\iar\..\..\..\lib\common\
#        -I
#        C:\Users\Chron\Desktop\智能车\私家车_葛峰\代码\mycar\project\mycar\iar\..\..\..\lib\LPLD\
#        -I
#        C:\Users\Chron\Desktop\智能车\私家车_葛峰\代码\mycar\project\mycar\iar\..\..\..\lib\LPLD\HW\
#        -I
#        C:\Users\Chron\Desktop\智能车\私家车_葛峰\代码\mycar\project\mycar\iar\..\..\..\lib\LPLD\DEV\
#        -I
#        C:\Users\Chron\Desktop\智能车\私家车_葛峰\代码\mycar\project\mycar\iar\..\..\..\lib\LPLD\FUNC\
#        -I
#        C:\Users\Chron\Desktop\智能车\私家车_葛峰\代码\mycar\project\mycar\iar\..\..\..\lib\uCOS-II\Ports\
#        -I
#        C:\Users\Chron\Desktop\智能车\私家车_葛峰\代码\mycar\project\mycar\iar\..\..\..\lib\uCOS-II\Source\
#        -I
#        C:\Users\Chron\Desktop\智能车\私家车_葛峰\代码\mycar\project\mycar\iar\..\..\..\lib\FatFs\
#        -I
#        C:\Users\Chron\Desktop\智能车\私家车_葛峰\代码\mycar\project\mycar\iar\..\..\..\lib\FatFs\option\
#        -I
#        C:\Users\Chron\Desktop\智能车\私家车_葛峰\代码\mycar\project\mycar\iar\..\..\..\lib\USB\common\
#        -I
#        C:\Users\Chron\Desktop\智能车\私家车_葛峰\代码\mycar\project\mycar\iar\..\..\..\lib\USB\driver\
#        -I
#        C:\Users\Chron\Desktop\智能车\私家车_葛峰\代码\mycar\project\mycar\iar\..\..\..\lib\USB\descriptor\
#        -I
#        C:\Users\Chron\Desktop\智能车\私家车_葛峰\代码\mycar\project\mycar\iar\..\..\..\lib\USB\class\
#        -Ol -I "E:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\CMSIS\Include\" -D ARM_MATH_CM4
#    List file    =  
#        C:\Users\Chron\Desktop\智能车\私家车_葛峰\代码\mycar\project\mycar\iar\FLASH\List\Search.lst
#    Object file  =  
#        C:\Users\Chron\Desktop\智能车\私家车_葛峰\代码\mycar\project\mycar\iar\FLASH\Obj\Search.o
#
###############################################################################

C:\Users\Chron\Desktop\智能车\私家车_葛峰\代码\mycar\project\mycar\app\Search.c
      1          #include "include.h"
      2          #define left 0
      3          #define right 1
      4          int Max_Peak,Left,Right;
      5          int leftfind,rightfind;    //左右边沿都找到了，但是不能直接赋值的那种
      6          float Middle_Err;
      7          int   CCD_Diff[128],RisingEdgeIndex,FallingEdgeIndex;
      8          uint8 RisingEdgeCnt,FallingEdgeCnt,RisingEdge[5],FallingEdge[5];
      9          
     10          float  Previous_Width[15];
     11          float  Previous_Angle[15];
     12          float  Previous_Error[15]; 
     13          int    Both_Line_find_cnt=0;
     14          
     15          uint8 state_change=0;
     16          
     17          uint8 Hill_Flag=0;
     18          
     19          uint8 Leftlast,Rightlast,Leftlastfind=0,Rightlastfind=0;
     20          int Reference_Width=50;             //参考宽度
     21          float Normal_Width=0;                 //正常赛道的宽度
     22          int  Right_Or_Left;
     23          int Turn_To_Angle=0;
     24          uint8 Strong_Turn_Cnt=0,Strong_Turn_En=0;
     25          float Character_Distance=0;
     26          float Last_Singleine_Position;
     27          float Last_Angle_Turn_Position=0;
     28          int Turn_State;
     29          int Turn_State_Cnt=0;
     30          
     31          
     32          float Last_Hill_Distance=0;
     33          
     34          
     35          uint8 Single_Out_Detect=0;
     36          
     37          int Turn_State1To2_Left,Turn_State1To2_Right;
     38          uint8 Refind_Cnt=0;
     39          
     40          uint8 Strong_Turn_Angle;
     41          uint8 Strong_Turn_Speed;
     42          
     43          uint8 Barri_Turn_Angle;
     44          uint8 Barri_Turn_Speed;
     45          
     46          uint8 curve_to_cross=0;
     47          
     48          uint8 RoadType;
     49          uint8 RoadTypeConfirm;             //赛道类型确认
     50          uint8 Threshold;                 //阈值
     51           
     52          uint8 RoadTypeSwitch=40;
     53          
     54          void RoadType_Distinguish()
     55          {
     56            uint8 i=0;
     57            int left_c,right_c;
     58            static float middle_last;
     59            Max_Peak=0;
     60            RisingEdgeCnt=0;
     61            FallingEdgeCnt=0;
     62            for(i=0;i<5;i++)
     63            {
     64              RisingEdge[i]=0;
     65              FallingEdge[i]=0;  
     66            }
     67            for(i=3;i<128;i++)
     68            {
     69              CCD_Diff[i]= CCD_Buff[i]- CCD_Buff[i-3];
     70              if(ABS(CCD_Diff[i])>Max_Peak) Max_Peak=ABS(CCD_Diff[i]); //求出最大的差分值
     71            }
     72            
     73            for(i=4;i<127;i++)
     74            {
     75              if((CCD_Diff[i]>=CCD_Diff[i-1])&&(CCD_Diff[i]>CCD_Diff[i+1])&&(CCD_Diff[i]>Threshold)) //寻找正的峰值，左边线
     76              {
     77                if(RisingEdgeCnt<5)    //一行图像最多有5个上跳沿
     78                { 
     79                 RisingEdge[RisingEdgeCnt]=i;
     80                 RisingEdgeCnt++;  
     81                }
     82              } 
     83              if((CCD_Diff[i]<CCD_Diff[i-1])&&(CCD_Diff[i]<=CCD_Diff[i+1])&&(CCD_Diff[i]<-Threshold))  //寻找负的峰值，右边线
     84              {
     85                if(FallingEdgeCnt<5)    //一行图像最多有5个下跳沿
     86                {
     87                 FallingEdge[FallingEdgeCnt]=i;
     88                 FallingEdgeCnt++;
     89                }
     90              }
     91            }
     92            if(Distance-Last_Singleine_Position>0.5&&RoadType==0) Prejudge();     //赛道类型预判
     93            switch(RoadType)
     94            {
     95             case 0:
     96              Character_Distance=0;
     97              Normal();
     98              
     99              Is_Straight_Angle_Turn();  //判断是否是弯入直角 
    100              Is_Barraicade();  
    101              
    102               if(RoadType==1)
    103              { 
    104                curve_to_cross=0;
    105              }
    106              else Is_CrossRoad();
    107              Single_Out_Detect=1;
    108              Is_Single_Line();      //检测边线外部是否有线
    109              Single_Out_Detect=0;
    110              ////////////////////////////////////////////////////////////////////////////////////////////????????????????????????????????????????????????????????????????????
    111              if(((Rightlastfind==0)||(Leftlastfind==0))&&(Distance-Last_Hill_Distance<2)&&(RoadTypeSwitch&64))
    112              {
    113                
    114                Character_Distance=Distance-1;   
    115                state_change=0;     
    116                RoadType=4;
    117                Turn_State=1;  
    118                Refind_Cnt=0;
    119                Strong_Turn_En=1;
    120                Strong_Turn_Cnt=0;
    121                Turn_Angle_Integral=0;    
    122                Turn_State1To2_Left=Left;
    123                Turn_State1To2_Right=Right;
    124               
    125                if(Leftlastfind==0)
    126                {
    127                  Right_Or_Left=1; //左直角 
    128                }
    129                else  Right_Or_Left=-1; //右直角 
    130                
    131              }
    132                
    133          
    134             break;
    135             case 1:
    136              CrossRoad();
    137              middle_last=Middle_Err;
    138             break;
    139             case 2:
    140              Barraicade();
    141             break;
    142             case 3:
    143              SingleLine(); 
    144             break;
    145             case 4:
    146              RightAngleTurn();
    147             break;
    148             case 5:
    149              Hill(); 
    150             break;
    151             default:
    152              Normal(); 
    153             break;
    154            }
    155            
    156            if(Distance<0.4)
    157            {
    158              RoadType=0;
    159              Last_Singleine_Position=0;
    160            }
    161            
    162            if(Stop==0&&RoadType!=0)
    163              TEST_HIGH;
    164            else 
    165              TEST_LOW;
    166            
    167             CCD_Draw_Buff[128]=Left-1;
    168             CCD_Draw_Buff[129]=Right; 
    169             CCD_Draw_Buff[132]=BYTE0(Max_Peak);
    170             CCD_Draw_Buff[133]=BYTE1(Max_Peak);
    171             CCD_Draw_Buff[134]=Leftlastfind;
    172             CCD_Draw_Buff[135]=Rightlastfind;
    173             CCD_Draw_Buff[136]=RoadType; 
    174          
    175             Leftlast=Left;              // 更新边界线
    176             Rightlast=Right;            //更新边界线
    177             left_c=Left-1;              //减去2修正差分误差
    178             right_c=Right;
    179             
    180               //判断一下是否为坡道
    181             if(RoadType!=4)Is_Hill(); 
    182             
    183             if(Rightlastfind||Leftlastfind)
    184             {
    185               Middle_Err=64-(right_c+left_c)/2.0+1;  //除以二会损失精度      
    186               if(ABS(Middle_Err-middle_last)>2&&(curve_to_cross==0))
    187               {
    188                 if(RoadType!=4&&RoadType!=2)
    189                 {
    190                   if(ABS(Middle_Err-middle_last)>3)
    191                   {
    192                    if(Middle_Err>middle_last) Middle_Err=middle_last+1;
    193                    else Middle_Err=middle_last-1;
    194                   }
    195                   else
    196                   {
    197                    if(Middle_Err>middle_last) Middle_Err=middle_last+2;
    198                    else Middle_Err=middle_last-2;
    199                   }
    200                 }
    201               }
    202               middle_last=Middle_Err;
    203             } 
    204             
    205             //更新队列 
    206             Push_And_Pull(Previous_Width,15,(float)(Right-Left));
    207             Push_And_Pull(Previous_Angle,15,Car_Angle);
    208             Push_And_Pull(Previous_Error,15,Middle_Err);
    209             
    210             if(Rightlastfind&&Leftlastfind)
    211             {
    212               if(Both_Line_find_cnt<20)Both_Line_find_cnt++;
    213             }
    214             else Both_Line_find_cnt=0;
    215             
    216             
    217             if(Rightlastfind&&Leftlastfind&&(Right-Left>20))   //两边边线都能够找到，计算赛道的平均亮度
    218             {
    219               Brightness_Calculate();
    220             }
    221          }
    222          void Prejudge()   //预判函数
    223          {
    224             if(RisingEdgeCnt==0&&FallingEdgeCnt==0)//说明没有跳边沿，全白
    225             {
    226                RoadType=1;
    227                curve_to_cross=0;
    228                Character_Distance=Distance;
    229             }
    230             else
    231             {
    232                 Is_Single_Line();
    233             }
    234          }
    235          void Normal()
    236          {
    237            uint8 tempwidth;
    238            if(Leftlastfind==0&&Rightlastfind==0)    //上次没有边线
    239            {
    240              Find_Bothine();
    241              if(Leftlastfind==0&&Rightlastfind==0)
    242              {
    243                 if(FindBoundary(left))
    244                 {
    245                  Left=RisingEdge[RisingEdgeIndex];
    246                  Leftlastfind=1; 
    247                  if(Left<34&&RoadType==4)Leftlastfind=0;
    248                 }
    249                 else  Leftlastfind=0;
    250                 if(FindBoundary(right))
    251                 {
    252                  Right=FallingEdge[FallingEdgeIndex];
    253                  Rightlastfind=1;
    254                  if(Right>84&&RoadType==4)Rightlastfind=0;
    255                 }
    256                 else  Rightlastfind=0; 
    257                 if(Leftlastfind&&Rightlastfind)
    258                 {
    259                  if(Right<Left)
    260                  {
    261                   Leftlastfind=0;
    262                   Rightlastfind=0;
    263                  }
    264                 }
    265              }
    266            }
    267            else                                    //上次至少找到一边
    268            {  
    269              //////////////////////////////
    270             if(Leftlastfind)						//上次找到了左线
    271             {
    272              if(FindNearest(left,Leftlast))		//这次能找到左线
    273              {
    274                Left=RisingEdge[RisingEdgeIndex];
    275                Leftlastfind=1;			
    276                if(Rightlastfind==0)				//上次找到左线，这次找到左线，上次没找到右线
    277                {
    278                 if(FallingEdgeCnt)					//上次找到左线，这次找到左线，上次没找到右线，这次找到右线
    279                 {
    280                   for(FallingEdgeIndex=0;FallingEdgeIndex<FallingEdgeCnt;FallingEdgeIndex++)
    281                   { 
    282                      rightfind=0;   //
    283                      if(FallingEdge[FallingEdgeIndex]>Left)         //找到潜在的边线了
    284                     {  
    285                       tempwidth = FallingEdge[FallingEdgeIndex]-Left;
    286                       if(ABS(tempwidth-Reference_Width)>=2)       //右线出现的太左了，慢慢靠近
    287                       {
    288                         if(tempwidth>Reference_Width)   Reference_Width=Reference_Width+1;   //潜在的赛道边线比参考宽度宽太多
    289                         else                         
    290                         {
    291                           Reference_Width=Reference_Width-1;   //潜在的赛道边线比参考宽度窄太多
    292                           if((RoadType==0)&&(Distance-Last_Singleine_Position<0.5))
    293                           Reference_Width=Reference_Width-1;
    294                         }
    295                         Right=Left+Reference_Width;
    296                         Rightlastfind = 0;
    297                       }
    298                       else 
    299                       {
    300                        Right=FallingEdge[FallingEdgeIndex];
    301                        Rightlastfind=1;
    302                       }
    303                       rightfind=1;   //找到边线了，但是还不能立马赋值
    304                       break;
    305                     }
    306                   } 
    307                     if(Rightlastfind==0&&rightfind==0)   //虽然说有上升沿，但是该上升沿无效
    308                    {
    309                      if(CarSpeed>2.5)          //在车模的速度足够块的情况下才这样弄
    310                      {
    311                       if(Left+Reference_Width<=118)  //虚拟出来的右边线要往外靠，但是不能靠得太狠了
    312                       {
    313                        Reference_Width++;
    314                       }
    315                       else 
    316                       {
    317                        Reference_Width=118-Left;
    318                       }
    319                      }
    320                     Right=Left+Reference_Width;
    321                    }
    322                 }
    323                 else                        //没有下跳沿                                  
    324                 {
    325                          if(CarSpeed>2.5)   
    326                        {
    327                         if(Left+Reference_Width<=118)  //虚拟出来的右边线要往外靠，但是不能靠得太狠了
    328                         {
    329                          Reference_Width++;
    330                         }
    331                         else 
    332                         {
    333                          Reference_Width=118-Left;
    334                         } 
    335                        }
    336                        Right=Left+Reference_Width;
    337                 }
    338                }
    339              }
    340              else  //上次能找到左线，这次没能找到左线
    341              {
    342                 Leftlastfind=0;   //丢线 
    343                  /*           跳转到十字           */   
    344                if(FindBoundary(left))
    345               {
    346                if(RisingEdge[RisingEdgeIndex]<Leftlast)  //这次没能够找到与上次相邻的边界，但是有边界却比现有的边界宽
    347                {
    348                  if(Rightlastfind==0&&((RoadType!=5)&&(RoadType!=4)))   //上次没有找到右边界，这次左边界又往外靠，那么就是遇到十字了
    349                  {
    350                   RoadType=1; 
    351                   Character_Distance=Distance; 
    352                  }
    353                }
    354                else if(RisingEdge[RisingEdgeIndex]<Leftlast+8)   //这次的边界比上次更靠近中央，但是他们的差值不大于8
    355                {
    356               //  Left=RisingEdge[RisingEdgeIndex];
    357                // Leftlastfind=1;                 //未丢线		 
    358                }
    359               } 
    360                else                     //不能找到左边界
    361               {
    362                 if(Rightlastfind==0&&(RoadType!=4))  
    363                 {
    364                  RoadType=1;
    365                  Character_Distance=Distance;
    366                 }
    367               }
    368              }
    369             }
    370             ///////////////////////////////
    371             if(Rightlastfind)					//上次找到了右线
    372             {
    373              if(FindNearest(right,Rightlast))	//这次能找到右线
    374              {
    375                Right=FallingEdge[FallingEdgeIndex];
    376                Rightlastfind=1;
    377                if(Leftlastfind==0)				//上次找到了右线,这次能找到右线,上次找不到左线
    378                {
    379                 if(RisingEdgeCnt>0)				//上次找到了右线,这次能找到右线,上次找不到左线,这次找到了左线
    380                 {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
    381          	 for(RisingEdgeIndex=RisingEdgeCnt-1;RisingEdgeIndex>=0;RisingEdgeIndex--)
    382                   {
    383                     leftfind=0;
    384                     if(RisingEdge[RisingEdgeIndex]<Right)         //找到潜在的边线了
    385                     {
    386                       tempwidth = Right-RisingEdge[RisingEdgeIndex];
    387                       if (ABS(tempwidth-Reference_Width)>=2)       //右线出现的太左了，慢慢靠近
    388                       {
    389                        if(tempwidth>Reference_Width)   Reference_Width=Reference_Width+1;   //潜在的赛道边线比参考宽度宽太多
    390                        else                          
    391                        {
    392                          Reference_Width=Reference_Width-1;   //潜在的赛道边线比参考宽度窄太多
    393                          if((RoadType==0)&&(Distance-Last_Singleine_Position<0.5))
    394                          Reference_Width=Reference_Width-1;   //潜在的赛道边线比参考宽度窄太多
    395                        }
    396                        Left=Right-Reference_Width;
    397                        Leftlastfind = 0;
    398                       }
    399                       else 
    400                       {
    401                         Left=RisingEdge[RisingEdgeIndex];
    402                         Leftlastfind=1;
    403                       }
    404                      leftfind=1;
    405                      break;
    406                     }          
    407                   }
    408                      if(Leftlastfind==0&&leftfind==0)   //虽然说有上升沿，但是该上升沿无效
    409                      {
    410                        if(CarSpeed>2.5)              //速度限制，防止出线
    411                          {
    412                           if(Right-Reference_Width>=10)  //虚拟出来的右边线要往外靠，但是不能靠得太狠了
    413                           {
    414                              Reference_Width++;
    415                           }
    416                           else 
    417                           {
    418                              Reference_Width=Right-10;
    419                           } 
    420                          }
    421                         Left=Right-Reference_Width;
    422                      }
    423                 }
    424                 else                               //没有上升沿哦亲
    425                 { 
    426                   if(CarSpeed>2.5)              //速度限制，防止出线
    427                    {
    428                     if(Right-Reference_Width>=10)  //虚拟出来的右边线要往外靠，但是不能靠得太狠了
    429                     {
    430                         Reference_Width++;
    431                     }
    432                     else 
    433                     {
    434                        Reference_Width=Right-10;
    435                     } 
    436                    }
    437                   Left=Right-Reference_Width;
    438                 }
    439                }
    440              }
    441              else  //上次能找到，这次没能找到与上次相邻近的线
    442              {
    443                Rightlastfind=0;   //丢线
    444               /*           跳转到十字           */
    445               if(FindBoundary(right))   //能够找到右边界
    446               {
    447                if(FallingEdge[FallingEdgeIndex]>Rightlast)  //这次没能够找到与上次相邻的边界，但是有边界却比现有的边界宽
    448                {
    449                  if(Leftlastfind==0&&((RoadType!=5)&&(RoadType!=4)))   //上次没有找到左边界，这次右边界又往外靠，那么就是遇到十字了
    450                  {
    451                   RoadType=1; 
    452                   Character_Distance=Distance;
    453                  }
    454                }
    455                else if(FallingEdge[FallingEdgeIndex]>Rightlast-8)  //这次的边界比上次更靠近中央，但是他们的差值不大于8
    456                {
    457              //    Right=FallingEdge[FallingEdgeIndex];
    458               //   Rightlastfind=1;           //其实是未丢线
    459                }
    460               }
    461               else                     //不能找到右边界
    462               {
    463                  if(Leftlastfind==0&&(RoadType!=4))   //上次没有找到左边界，这次右边界又往外靠，那么就是遇到十字了
    464                 {
    465                   RoadType=1;
    466                   Character_Distance=Distance;
    467                 }
    468               }
    469              }
    470             }
    471             //都能找到边线，更新参考宽度
    472             if(Rightlastfind&&Leftlastfind)
    473             {
    474               
    475               Reference_Width=Right-Left; 
    476               if(Reference_Width<35)Reference_Width=35;
    477             }
    478            }
    479          }
    480          void CrossRoad()
    481          {
    482             static uint8 Normal_Cnt;
    483             static uint8 Cross_Road_Cnt=0;
    484            
    485              //缓慢归零，车子回正  
    486            if(curve_to_cross==0)
    487            {  
    488              Rightlastfind=0;
    489              Leftlastfind=0; 
    490            }
    491            else
    492            {  
    493              if(Rightlastfind)
    494              {
    495                  if(FindNearest(right,Rightlast))		//这次能找到左线
    496                 {
    497                  Right=FallingEdge[FallingEdgeIndex];
    498                  Rightlastfind=1;
    499                  Left=Right-Reference_Width;
    500                 }
    501                 else 
    502                 {
    503                   Rightlastfind=0;
    504                   //curve_to_cross=0;
    505                 }
    506              }
    507              else if(Leftlastfind)
    508              {
    509                if(FindNearest(left,Leftlast))		//这次能找到左线
    510               {
    511                Left=RisingEdge[RisingEdgeIndex];    
    512                Leftlastfind=1;
    513                Right=Reference_Width+Left;
    514               }
    515               else 
    516               {
    517                 Leftlastfind=0;
    518                // curve_to_cross=0;
    519               }
    520              }
    521            }
    522            
    523              if(ABS(Middle_Err)>1)
    524              {
    525                if(curve_to_cross==0)
    526                {
    527                 if(Middle_Err>0)Middle_Err=Middle_Err-1.2;     
    528                 if(Middle_Err<0)Middle_Err=Middle_Err+1.2;
    529                }
    530              }
    531              else Middle_Err=0;
    532              
    533              if((curve_to_cross==0)&&Is_Black_Line()&&(Distance-Character_Distance<0.15))
    534              {
    535                    RoadType=4;
    536                    Turn_To_Angle=0;//??????????????????????????????????
    537                    Strong_Turn_Cnt=0;
    538                    Strong_Turn_En=0;
    539                    Turn_State=0;
    540                    Turn_Angle_Integral=0;
    541              }
    542              
    543          
    544              
    545              if((Stop==0)&&(Distance-Character_Distance>0.7)&&Protect&&(curve_to_cross==0))                             //跑出去了
    546              {
    547                Stop=true;
    548                CarStopedJustNow=true; 
    549              }
    550              
    551            
    552              
    553              
    554              
    555              if(curve_to_cross==0||(curve_to_cross==1&&Distance-Character_Distance>0.5)) Find_Bothine();
    556              
    557              if(Rightlastfind&&Leftlastfind)//能够找到两边边界
    558              {
    559               if(Right-Left<65&&Cross_Road_Cnt>4)     //宽度有效
    560               {
    561                  /*                跳转到直角弯                 */
    562                  if(Distance>1&&(Distance-Character_Distance<0.15))
    563                  {
    564                    RoadType=4;
    565                    Turn_Angle_Integral=0;
    566                    Turn_To_Angle=0;
    567                    Strong_Turn_Cnt=0;
    568                    Strong_Turn_En=0;
    569                    Turn_State=0;                       
    570                  }
    571                  else
    572                  { 
    573                    Normal_Cnt++;
    574                    if(Normal_Cnt>=3)
    575                    {
    576                     RoadType=0;
    577                     curve_to_cross=0;
    578                    /*            跳回正常道路            */
    579                    }
    580                   
    581                  }
    582               }
    583               else 
    584               {
    585                Rightlastfind=0;
    586                Leftlastfind=0;
    587                Normal_Cnt=0;
    588               }
    589              }
    590              else Normal_Cnt=0;
    591              
    592               if(curve_to_cross&&(Distance-Character_Distance>0.1)&&(Distance-Character_Distance<0.32))
    593              {
    594                 Is_Single_Line();//说明出现误识别了；
    595              }
    596          
    597              if(RoadType!=1)
    598              {
    599                Cross_Road_Cnt=0;
    600              }
    601              else
    602              {
    603                if(Cross_Road_Cnt<10)Cross_Road_Cnt++; 
    604                
    605                if(Cross_Road_Cnt>3&&Cross_Road_Cnt<8&&curve_to_cross==0)/////////////////////////////////改
    606                {
    607                  Leftlastfind=0;
    608                  Rightlastfind=0;
    609                  Is_Single_Line();//说明出现误识别了；
    610                }
    611                
    612              }
    613          }
    614          void Barraicade()
    615          {
    616            int i;
    617            
    618             if(Right_Or_Left==left) //障碍在左边
    619             {
    620               if(FindNearest(right,Rightlast))
    621               {
    622                Right=FallingEdge[FallingEdgeIndex];
    623                Rightlastfind=1;
    624               }
    625               else Rightlastfind=0;
    626               if(Distance-Character_Distance<0.25)
    627               {
    628                 Leftlastfind=0;
    629                 if(RisingEdgeCnt>0)  
    630                 {
    631                  for(i=RisingEdgeCnt-1;i>=0;i--)
    632                  {
    633                   if(RisingEdge[i]+10<Right) 
    634                   {
    635                    Left=RisingEdge[i]; 
    636                    Leftlastfind=1;
    637                    break;
    638                   }
    639                  }
    640                 }
    641               }
    642               else
    643               {
    644                 if(FindNearest(left,Leftlast))
    645                 {
    646                  Left=RisingEdge[RisingEdgeIndex];
    647                 Leftlastfind=1;
    648                 }
    649                 else Leftlastfind=0;
    650               }
    651               
    652               if(Leftlastfind&&Rightlastfind)Reference_Width=Right-Left;
    653               else
    654               {
    655                Left=Right-Reference_Width;
    656               }
    657             }
    658             else   //障碍在右边
    659             { 
    660               if(FindNearest(left,Leftlast))
    661               {
    662                Left=RisingEdge[RisingEdgeIndex];
    663                Leftlastfind=1;
    664               }
    665               else Leftlastfind=0;
    666               if(Distance-Character_Distance<0.25)
    667               {
    668                 Rightlastfind=0;
    669                 if(FallingEdgeCnt>0)  
    670                 {
    671                   for(i=0;i<FallingEdgeCnt;i++)
    672                    {
    673                     if(FallingEdge[i]>Left+10) 
    674                     {
    675                      Right=FallingEdge[i]; 
    676                      Rightlastfind=1;
    677                      break;
    678                     }
    679                    }
    680                 }
    681               }
    682               else
    683               {
    684                  if(FindNearest(right,Rightlast))
    685                 {
    686                  Right=FallingEdge[FallingEdgeIndex];
    687                  Rightlastfind=1;
    688                 }
    689                 else Rightlastfind=0;
    690               }
    691               
    692               if(Leftlastfind&&Rightlastfind)Reference_Width=Right-Left;
    693               else
    694               {
    695                 Right=Left+Reference_Width;
    696               }
    697             }
    698             Turn_State_Cnt++;
    699             if(Distance-Character_Distance>0.5)
    700             RoadType=0;
    701          }
    702          void SingleLine()
    703          {
    704            int i=0,j=0;
    705            static int lostcnt;
    706            static int SharpTurn_Lost=0;
    707            
    708            Leftlastfind=0;
    709            Rightlastfind=0;
    710            
    711            for(i=Left-5;i<=Left+5;i++)           
    712            {
    713              if((CCD_Diff[i]<CCD_Diff[i-1])&&(CCD_Diff[i]<=CCD_Diff[i+1])&&(CCD_Diff[i]<-Threshold))  //寻找负的峰值
    714              {   
    715                Left=i;
    716                Leftlastfind=1;
    717                lostcnt=0;
    718                break;
    719              }
    720            }
    721            
    722            for(j=Right-5;j<=Right+5;j++)
    723            {
    724              if((CCD_Diff[j]>=CCD_Diff[j-1])&&(CCD_Diff[j]>CCD_Diff[j+1])&&(CCD_Diff[j]>Threshold)) //寻找正的峰值
    725              {
    726                 Right=j;
    727                 Rightlastfind=1;
    728                 lostcnt=0;
    729                 break;
    730              }
    731            }
    732            
    733            if((Leftlastfind==0)&&(Rightlastfind==0)) ///////////////注意！！！！！
    734            {     
    735                lostcnt++;
    736              
    737                if(lostcnt>=3) 
    738                {
    739                      
    740                  if(((Distance-Character_Distance)>0.1)&&((Distance-Character_Distance)<0.4)&&(ABS(Middle_Err)>10))
    741                  {
    742                   SharpTurn_Lost=1;
    743                  }
    744                  
    745                  if(Distance-Character_Distance<0.2)           //距离判定说明是误判，应该转到直角里面                                   /////////不起作用吧？？？？？？？？？？？？？？
    746                  {
    747                    RoadType=4;
    748                    Turn_Angle_Integral=0;
    749                    Turn_To_Angle=0;
    750                    Strong_Turn_Cnt=0;
    751                    Strong_Turn_En=0;
    752                    Turn_State=0;             
    753                  }
    754                  else                                          //确实是单线而且现在是出单线的情况了
    755                  {
    756                     
    757                     if(SharpTurn_Lost==0) 
    758                    {                      
    759                        for(i=Left-10;(i>Left-40)&&(i>0);i--)           
    760                      {           
    761                        if((CCD_Diff[i]>=CCD_Diff[i-1])&&(CCD_Diff[i]>CCD_Diff[i+1])&&(CCD_Diff[i]>Threshold*2))  //寻找正的峰值
    762                        {   
    763                          Left=i;
    764                          Leftlastfind=1;
    765                          break;
    766                        }
    767                      }
    768                      
    769                      
    770                       for(j=Right+10;(j<Right+40)&&(j<125);j++)
    771                      {
    772                        if((CCD_Diff[j]<CCD_Diff[j-1])&&(CCD_Diff[j]<=CCD_Diff[j+1])&&(CCD_Diff[j]<-Threshold*2)) //寻找负的峰值
    773                        {
    774                           Right=j;
    775                           Rightlastfind=1;
    776                           break;
    777                        }
    778                      }
    779                    
    780                      if(Rightlastfind||Leftlastfind) 
    781                      {
    782                       if(Rightlastfind==0) Right=(64-(int)Middle_Err)*2-Left;
    783                       if(Leftlastfind==0) Left=(64-(int)Middle_Err)*2-Right;
    784                       RoadType=0;
    785                       Last_Singleine_Position=Distance;
    786                       lostcnt=0; 
    787                      }
    788                    }
    789                    else
    790                    {  
    791                      if(Middle_Err<0)
    792                      {
    793                        for(i=Left;i<120;i++)         
    794                       {
    795                        if((CCD_Diff[i]<CCD_Diff[i-1])&&(CCD_Diff[i]<=CCD_Diff[i+1])&&(CCD_Diff[i]<-Threshold))  //寻找负的峰值
    796                        {
    797                          for(j=i+2;(j<=i+10)&&(j<125);j++) 
    798                          {
    799                            if((CCD_Diff[j]>=CCD_Diff[j-1])&&(CCD_Diff[j]>CCD_Diff[j+1])&&(CCD_Diff[j]>Threshold)) //寻找正的峰值
    800                            {
    801                              Left=i;
    802                              Leftlastfind=1;
    803                              Right=j;
    804                              Rightlastfind=1;
    805                              SharpTurn_Lost=0;
    806                              lostcnt=0;
    807                            }
    808                          }
    809                        }
    810                       }
    811                      }          
    812                      if(Middle_Err>0)
    813                      {
    814                        for(i=Right;i>1;i--)         
    815                       {
    816                        if((CCD_Diff[i]<CCD_Diff[i-1])&&(CCD_Diff[i]<=CCD_Diff[i+1])&&(CCD_Diff[i]<-Threshold))  //寻找负的峰值
    817                        {
    818                          for(j=i+2;j<=i+10;j++) 
    819                          {
    820                            if((CCD_Diff[j]>=CCD_Diff[j-1])&&(CCD_Diff[j]>CCD_Diff[j+1])&&(CCD_Diff[j]>Threshold)) //寻找正的峰值
    821                            {
    822                              Left=i;
    823                              Leftlastfind=1;
    824                              Right=j;
    825                              Rightlastfind=1;
    826                              SharpTurn_Lost=0;
    827                              lostcnt=0;
    828                            }
    829                          }
    830                        }
    831                       }
    832                      }
    833                    }
    834                  }
    835                }
    836              }
    837            
    838             if(Leftlastfind&&Rightlastfind) ///////////////注意！！！！！
    839            {
    840             if(ABS(Right-Left)>12)
    841             {
    842               RoadType=0;
    843               Last_Singleine_Position=Distance;
    844               Leftlastfind=0;
    845               Rightlastfind=0;
    846               Find_Bothine();
    847             }
    848            }
    849             
    850             if(RoadType!=3) SharpTurn_Lost=0;
    851            
    852          }
    853          
    854          ///////////////////////////////////////////////////////直角弯道////////////////
    855          void RightAngleTurn()
    856          { 
    857            static uint8 tuofengDisapear=0;
    858            static uint8 Lastine,Lastine_R,Refind_Cnt_R;
    859            uint8 refind=0;
    860            static int Cross_cnt=0;
    861            uint8 j=0;
    862            state_change=0;
    863            if(Distance-Character_Distance<0.1) tuofengDisapear=0;
    864            /***********************状态0,两边都能找到线********************/
    865            if(Turn_State==0)
    866            {   
    867               if(Turn_To_Angle!=0)
    868               {
    869                 if(Turn_To_Angle==1)  //右转入直角
    870                 { 
    871                    if(tuofengDisapear==0) Cross_cnt++;
    872                    if(FindNearest(left,Leftlast))
    873                   {
    874                      Left=RisingEdge[RisingEdgeIndex];
    875                      Leftlastfind=1;         
    876                      if(Rightlastfind==0&&Cross_cnt<=10&&(tuofengDisapear==0))
    877                      {
    878                        if(FallingEdgeCnt==0)
    879                        {
    880                          RoadType=0;
    881                          Cross_cnt=0; 
    882                        }     
    883                        else  if(FallingEdge[FallingEdgeCnt-1]<Left)  
    884                        {   
    885                          RoadType=0;
    886                          Cross_cnt=0; 
    887                        }
    888                      }
    889                   }
    890                   else
    891                   { 
    892                     Cross_cnt=0;
    893                     Leftlastfind=0;
    894                     if(Distance-Character_Distance>0.1)  tuofengDisapear=1; //边沿有跳变，驼峰消失        
    895                     if(Distance-Character_Distance<0.60)
    896                     {
    897                       for(RisingEdgeIndex=RisingEdgeCnt-1;RisingEdgeIndex>=0;RisingEdgeIndex--)
    898                       {
    899                        if(((RisingEdge[RisingEdgeIndex]>=Left)&&(RisingEdge[RisingEdgeIndex]-Left<20))||ABS(RisingEdge[RisingEdgeIndex]-Left)<10)  
    900                        {
    901                            Leftlastfind=1;
    902                            Left=RisingEdge[RisingEdgeIndex];
    903                            break;
    904                        }
    905                       }
    906                       Character_Distance=Distance-0.1;
    907                     }           
    908                   }
    909                   //处理右边线
    910                                                                                              ///////////////////////
    911                   if(Rightlastfind==0)
    912                   {
    913                     if(RisingEdgeCnt>=1)
    914                     {
    915                         for(FallingEdgeIndex=FallingEdgeCnt-1;FallingEdgeIndex>=0;FallingEdgeIndex--)
    916                        {
    917                           if(FallingEdge[FallingEdgeIndex]-Left>35)
    918                           {
    919                             if(Rightlastfind==1)         //说明在驼峰之外还有边界
    920                             {
    921                               refind=1;
    922                               break;
    923                             }
    924                             else
    925                             {
    926                              Right=FallingEdge[FallingEdgeIndex];
    927                              Rightlastfind=1; 
    928                             }
    929                           }
    930                        }
    931                     }
    932                     if(refind==0&&tuofengDisapear==0)
    933                     {
    934                      Right=Left+Reference_Width; 
    935                      Refind_Cnt=0; 
    936                      Rightlastfind=0;
    937                     }
    938                     else
    939                     {
    940                      if(Rightlastfind==1)
    941                      {
    942                       Refind_Cnt++;
    943                       if(Refind_Cnt>=3) 
    944                       {
    945                         Character_Distance=Distance-0.1;
    946                         Rightlastfind=1;
    947                       }
    948                       else  Rightlastfind=0;
    949                      }
    950                     }
    951                   }
    952                   else
    953                   {
    954                      if(FindNearest(right,Rightlast))
    955                     {
    956                         Right=FallingEdge[FallingEdgeIndex];
    957                         Rightlastfind=1;
    958                     }
    959                     else Rightlastfind=0;
    960                   }                                                                           ///////////////////////
    961                   
    962                 }
    963                 else                  //左转入直角
    964                 {
    965                   if(tuofengDisapear==0) Cross_cnt++;
    966                   //处理右边线
    967                   if(FindNearest(right,Rightlast))
    968                   {
    969                    Right=FallingEdge[FallingEdgeIndex];      
    970                    Rightlastfind=1;
    971                    
    972                    
    973                    if(Leftlastfind==0&&Cross_cnt<=10&&(tuofengDisapear==0))
    974                    {
    975                      if(RisingEdgeCnt==0)
    976                      {
    977                        RoadType=0;
    978                        Cross_cnt=0; 
    979                      }     
    980                      else  if(RisingEdge[0]>Right)  
    981                      {   
    982                        RoadType=0;
    983                        Cross_cnt=0; 
    984                      }
    985                    }
    986            
    987                   }
    988                   else 
    989                   {  
    990                      Cross_cnt=0;
    991                     Rightlastfind=0; 
    992                     if(Distance-Character_Distance>0.1)  tuofengDisapear=1; //边沿有跳变，驼峰消失
    993                     if(Distance-Character_Distance<0.60)
    994                     {
    995                       for(FallingEdgeIndex=0;FallingEdgeIndex<FallingEdgeCnt;FallingEdgeIndex++)
    996                       {
    997                        if(((FallingEdge[FallingEdgeIndex]<Right)&&(Right-FallingEdge[FallingEdgeIndex]<20))||(ABS(Right-FallingEdge[FallingEdgeIndex])<10))
    998                        {
    999                            Rightlastfind=1;
   1000                            Right=FallingEdge[FallingEdgeIndex];
   1001                            break;
   1002                        }
   1003                       }
   1004                       Character_Distance=Distance-0.1;
   1005                     }  
   1006                   } 
   1007                   //处理左边线
   1008                   if(Leftlastfind==0)
   1009                   {
   1010                     if(RisingEdgeCnt>=1)
   1011                     {
   1012                         for(RisingEdgeIndex=0;RisingEdgeIndex<=RisingEdgeCnt-1;RisingEdgeIndex++)
   1013                        {
   1014                           if(Right-RisingEdge[RisingEdgeIndex]>35)
   1015                           {
   1016                             if(Leftlastfind==1)         //说明在驼峰之外还有边界
   1017                             {
   1018                               refind=1;
   1019                               break;
   1020                             }
   1021                             else
   1022                             {
   1023                              Left=RisingEdge[RisingEdgeIndex];
   1024                              Leftlastfind=1; 
   1025                             }
   1026                           }
   1027                        }
   1028                     }
   1029                     if(refind==0&&tuofengDisapear==0)
   1030                     {
   1031                      Left=Right-Reference_Width; 
   1032                      Refind_Cnt=0; 
   1033                      Leftlastfind=0;
   1034                     }
   1035                     else
   1036                     {
   1037                      if(Leftlastfind==1)
   1038                      {
   1039                       Refind_Cnt++;
   1040                       if(Refind_Cnt>=3) 
   1041                       {
   1042                         Character_Distance=Distance-0.1;
   1043                          Leftlastfind=1;
   1044                       }
   1045                       else  Leftlastfind=0;
   1046                      }
   1047                     }
   1048                   }
   1049                   ////////左边线已经从新找到
   1050                   else
   1051                   {
   1052                      if(FindNearest(left,Leftlast))
   1053                     {
   1054                         Left=RisingEdge[RisingEdgeIndex];
   1055                         Leftlastfind=1;
   1056                     }
   1057                     else Leftlastfind=0;
   1058                   }
   1059                 }
   1060               }
   1061            //////////////////////////////////////////////////
   1062               else                   //正入直角
   1063               {
   1064                 if(Distance-Character_Distance>0.1)
   1065                 {  
   1066                   Leftlastfind=0;
   1067                   Rightlastfind=0;
   1068                   if(RisingEdgeCnt!=0) 
   1069                   {
   1070                      for(RisingEdgeIndex=RisingEdgeCnt-1;RisingEdgeIndex>=0;RisingEdgeIndex--)
   1071                      {
   1072                         if(RisingEdge[RisingEdgeIndex]<64)
   1073                         {
   1074                            Leftlastfind=1;
   1075                            Left=RisingEdge[RisingEdgeIndex];
   1076                            break;
   1077                         }
   1078                      }
   1079                   }       
   1080                  if(FallingEdgeCnt!=0)  
   1081                  {
   1082                     for(FallingEdgeIndex=0;FallingEdgeIndex<FallingEdgeCnt;FallingEdgeIndex++)
   1083                     {
   1084                        if(FallingEdge[FallingEdgeIndex]>64)
   1085                        {
   1086                            Rightlastfind=1;
   1087                            Right=FallingEdge[FallingEdgeIndex];
   1088                           break;
   1089                        }
   1090                     }
   1091                   }
   1092                   Reference_Width=50;
   1093                   if(Rightlastfind==1&&Leftlastfind==0)
   1094                   {
   1095                     Left=Right-Reference_Width;
   1096                   }
   1097                   if(Rightlastfind==0&&Leftlastfind==1)
   1098                   {
   1099                     Right=Left+Reference_Width;
   1100                   }
   1101                 }
   1102               }
   1103              //////////////////////////      
   1104              if(Distance-Character_Distance>1.60)
   1105              {
   1106                RoadType=0;
   1107              }
   1108              
   1109              if((Distance-Character_Distance>0.80)&&(Leftlastfind==0||Rightlastfind==0))
   1110              {
   1111                Turn_State=1;
   1112                Refind_Cnt=0;
   1113                state_change=1;
   1114                Strong_Turn_En=1;
   1115                Turn_Angle_Integral=0;
   1116                Turn_State1To2_Left=Left;
   1117                Turn_State1To2_Right=Right;
   1118                if(Leftlastfind==0)
   1119                {
   1120                  Right_Or_Left=1; //左直角 
   1121                }
   1122                else
   1123                Right_Or_Left=-1;  //右直角
   1124              }
   1125            }
   1126            
   1127            
   1128            /********************状态1,进入了直角，强拐*********************/
   1129            if((Turn_State==1)&&(state_change==0))          //状态一 丢失了一条边线
   1130            {
   1131              Cross_cnt=0;
   1132              if(Right_Or_Left==1)
   1133              {   
   1134                  Rightlastfind=0;
   1135                  Leftlastfind=0;
   1136                  
   1137                  
   1138                 for(j=Turn_State1To2_Left-10;j>5;j--)
   1139                {
   1140                   if((CCD_Diff[j]>=CCD_Diff[j-1])&&(CCD_Diff[j]>CCD_Diff[j+1])&&(CCD_Diff[j]>Threshold)) //寻找正的峰值
   1141                   {          
   1142                    Left=j;
   1143                    Leftlastfind=1; 
   1144                    break;   
   1145                   }
   1146                 }
   1147                  
   1148                 if(Leftlastfind)             //左直角，重新找到左边线了
   1149                {
   1150                               
   1151                    for(j=Left;j<100;j++)
   1152                    {
   1153                       if((CCD_Diff[j]<CCD_Diff[j-1])&&(CCD_Diff[j]<=CCD_Diff[j+1])&&(CCD_Diff[j]<-Threshold))  //寻找负的峰值
   1154                      {
   1155                       Rightlastfind=1;
   1156                       Right=j;
   1157                       break;
   1158                      }
   1159                    }
   1160                   
   1161                   if(Lastine<=Left)
   1162                   {
   1163                     Refind_Cnt++;
   1164                     if(Refind_Cnt>=3)
   1165                     {
   1166                      Turn_State=2;
   1167                      state_change=1;
   1168                     }
   1169                   }
   1170                   else   Refind_Cnt=0;
   1171                   Lastine=Left;  
   1172                }
   1173                else    Refind_Cnt=0;
   1174                
   1175                 if(Rightlastfind==0)              //
   1176                {        
   1177                  for(j=Turn_State1To2_Left;j<100;j++)
   1178                  {
   1179                     if((CCD_Diff[j]<CCD_Diff[j-1])&&(CCD_Diff[j]<=CCD_Diff[j+1])&&(CCD_Diff[j]<-Threshold))  //寻找负的峰值
   1180                    {
   1181                     Rightlastfind=1;
   1182                     Right=j;
   1183                     break;
   1184                    }
   1185                  }
   1186                  if(Rightlastfind)
   1187                  {
   1188                   if(Lastine_R>Right)
   1189                   {
   1190                     Refind_Cnt_R++;
   1191                     if(Refind_Cnt_R>=3)
   1192                     {
   1193                      Turn_State=2;
   1194                      state_change=1;
   1195                     }
   1196                     else Rightlastfind=0;
   1197                   }
   1198                   else
   1199                   {
   1200                     Refind_Cnt_R=0;
   1201                     Rightlastfind=0;
   1202                   }
   1203                   Lastine_R=Right;  
   1204                  }
   1205                  else   Refind_Cnt_R=0;
   1206                }
   1207              }
   1208              else  //右直角                              有点问题哦
   1209              {  
   1210                Leftlastfind=0;
   1211                 Rightlastfind=0;
   1212                 
   1213                 for(j=Turn_State1To2_Right;j<125;j++)
   1214                {
   1215                   if((CCD_Diff[j]<CCD_Diff[j-1])&&(CCD_Diff[j]<=CCD_Diff[j+1])&&(CCD_Diff[j]<-Threshold))  //寻找负的峰值
   1216                  {
   1217                   Rightlastfind=1;
   1218                   Right=j;
   1219                   break;
   1220                  }
   1221                }
   1222                 
   1223                 if(Rightlastfind)             //右直角，重新找到右边线了
   1224                { 
   1225                    for(j=Right;j>20;j--)
   1226                    {
   1227                       if((CCD_Diff[j]>=CCD_Diff[j-1])&&(CCD_Diff[j]>CCD_Diff[j+1])&&(CCD_Diff[j]>Threshold)) //寻找正的峰值
   1228                      {
   1229                       Leftlastfind=1;
   1230                       Left=j;
   1231                       break;
   1232                      }
   1233                    }
   1234                  
   1235                   if(Lastine_R>=Right)
   1236                   {
   1237                     Refind_Cnt_R++;
   1238                     if(Refind_Cnt_R>=3)
   1239                     {
   1240                      Turn_State=2;
   1241                      state_change=1;
   1242                     }
   1243                   }
   1244                   else Refind_Cnt_R=0;
   1245                   Lastine_R=Right;  
   1246                 }
   1247                else  Refind_Cnt_R=0;
   1248               
   1249                if(Leftlastfind==0)
   1250               {
   1251                 for(j=Turn_State1To2_Right;j>5;j--)
   1252                {
   1253                   if((CCD_Diff[j]>=CCD_Diff[j-1])&&(CCD_Diff[j]>CCD_Diff[j+1])&&(CCD_Diff[j]>Threshold)) //寻找正的峰值
   1254                   {          
   1255                    Left=j;
   1256                    Leftlastfind=1; 
   1257                    break;   
   1258                   }
   1259                 }
   1260                 
   1261                 if(Leftlastfind)
   1262                {
   1263                 if(Lastine<Left)
   1264                 {
   1265                   Refind_Cnt++;
   1266                   if(Refind_Cnt>=3)
   1267                   {
   1268                    Turn_State=2;
   1269                    state_change=1;
   1270                   }
   1271                   else Leftlastfind=0;
   1272                 }
   1273                 else
   1274                 {
   1275                   Refind_Cnt=0;
   1276                   Leftlastfind=0;
   1277                 }
   1278                 Lastine=Left;  
   1279                }
   1280                 else Refind_Cnt=0;
   1281               }
   1282              }
   1283              
   1284              if(state_change==1)
   1285              {
   1286                 if(Strong_Turn_Cnt<20)     //防止过早地跳到Turn_State2中
   1287                 {
   1288                   Turn_State=1;
   1289                 }
   1290              }
   1291                  
   1292              Middle_Err=0;
   1293              
   1294            }
   1295            
   1296            static uint8 Width_Decrease_cnt;
   1297            static int Widthast;
   1298            int width;
   1299            
   1300            if((Turn_State==2)&&(state_change==0))
   1301            {
   1302              Normal();
   1303              RoadType=4;
   1304              
   1305              if(Distance-Character_Distance>2.0)
   1306              {
   1307                  if(Leftlastfind&&Rightlastfind)        //斜着出直角
   1308                {
   1309                  width=Right-Left;
   1310                  
   1311                  if(Widthast!=0)
   1312                  {
   1313                    if(Widthast-width>=2)
   1314                    {
   1315                     Width_Decrease_cnt++; 
   1316                    }
   1317                    else
   1318                    {
   1319                     Width_Decrease_cnt=0;  
   1320                    }
   1321                    if(Width_Decrease_cnt==2||(Widthast-width>=3))
   1322                    {
   1323                      Turn_State=3;
   1324                      state_change=1;
   1325                      Character_Distance=Distance;
   1326                      Leftlastfind=0;
   1327                      Rightlastfind=0;
   1328                    } 
   1329                  }
   1330                  Widthast=width;
   1331                }
   1332              
   1333               if(Leftlastfind==0||Rightlastfind==0) //直出直角
   1334               {  
   1335                 Turn_State=3;
   1336                 state_change=1;
   1337                 Character_Distance=Distance;
   1338                 Leftlastfind=0;
   1339                 Rightlastfind=0;
   1340               }
   1341              }
   1342              else
   1343              {
   1344                Widthast=0;
   1345                Width_Decrease_cnt=0;
   1346              }
   1347            }
   1348            if((Turn_State==3)&&(state_change==0))  //
   1349            {
   1350                if(Middle_Err>2) Middle_Err=Middle_Err-0.5;
   1351                if(Middle_Err<-2) Middle_Err=Middle_Err+0.5;
   1352                if(Distance-Character_Distance>0.2)
   1353                {
   1354                  Find_Bothine();
   1355                  if(Leftlastfind&&Rightlastfind)
   1356                  {
   1357                   if((Right-Left>25)&&(Right-Left<60)&&(ABS((Right+Left)/2-64))<15)
   1358                   {
   1359                     RoadType=0;
   1360                     Turn_State=0;
   1361                     Refind_Cnt=0;
   1362                   }
   1363                  }
   1364                } 
   1365                if(Distance-Character_Distance>0.3)
   1366                {
   1367                   RoadType=0;
   1368                  Turn_State=0;
   1369                  Refind_Cnt=0;
   1370                }
   1371                if(RoadType==0) Last_Angle_Turn_Position=Distance;
   1372                
   1373            }
   1374              if(Distance-Last_Angle_Turn_Position<0.5)RoadType=0;
   1375              
   1376              CCD_Draw_Buff[137]=Turn_State;
   1377          }
   1378          void Hill()
   1379          {
   1380            //////////用来在坡道上搜索线的变量/////////
   1381            uint8 i=0,j=0,threshold_t;
   1382            static uint8 lost_cnt;
   1383            ////////////////////////////
   1384            static uint8  Confirm_Cnt=0;  
   1385             if(RoadTypeConfirm==0)  //还没确认
   1386            {
   1387              Normal(); //调用normal函数来搜线 
   1388              if(Confirm_Cnt<5)      //用5个周期来确认
   1389              {
   1390                if(Leftlastfind==0||Rightlastfind==0||ABS(Middle_Err)>5)   //有一条边没找到说明这个其实是弯道
   1391                {
   1392                 RoadType=0; 
   1393                 Confirm_Cnt=0;
   1394                } 
   1395               else Confirm_Cnt++;
   1396              }
   1397              else RoadTypeConfirm=1;     //赛道类型确认了，确实是坡道 
   1398              lost_cnt=0;
   1399            }
   1400            else                                  //已经判断是坡道了
   1401            { 
   1402              Leftlastfind=0;
   1403              Rightlastfind=0;
   1404              threshold_t=Threshold;
   1405              while((Leftlastfind==0)&&(threshold_t*1.5>Threshold))
   1406              {
   1407                 for(i=Leftlast-6;i<=Leftlast+6;i++) ////////////////////////////////////////////////////////////////////////////////////////////???????????????????????????         
   1408                {
   1409                  if((CCD_Diff[i]>=CCD_Diff[i-1])&&(CCD_Diff[i]>CCD_Diff[i+1])&&(CCD_Diff[i]>threshold_t))  //寻找负的峰值
   1410                  {  
   1411                    Left=i;
   1412                    Leftlastfind=1;
   1413                  }
   1414                }
   1415                threshold_t=threshold_t-2;
   1416              } 
   1417              threshold_t=Threshold;
   1418              while((Rightlastfind==0)&&(threshold_t*1.5>Threshold))
   1419              {
   1420                for(j=Rightlast+6;j>=Rightlast-6;j--)
   1421                {
   1422                  if((CCD_Diff[j]<CCD_Diff[j-1])&&(CCD_Diff[j]<=CCD_Diff[j+1])&&(CCD_Diff[j]<-threshold_t)) //寻找正的峰值
   1423                  {
   1424                     Right=j;
   1425                     Rightlastfind=1;
   1426                  }
   1427                }
   1428                threshold_t=threshold_t-2;
   1429              }
   1430              
   1431              if((Leftlastfind==1)&&(Rightlastfind==0))/////////////////////////////////////??????????????????????????????????????????????????????????????????????????????
   1432              {
   1433                 for(j=Left+10;(j<=Left+50)&&(j<120);j++)
   1434                {
   1435                  if((CCD_Diff[j]<CCD_Diff[j-1])&&(CCD_Diff[j]<=CCD_Diff[j+1])&&(CCD_Diff[j]<-Threshold)) //寻找正的峰值
   1436                  {
   1437                     Right=j;
   1438                     Rightlastfind=1;
   1439                     break;
   1440                  }
   1441                }
   1442              }
   1443                
   1444              if((Leftlastfind==0)||(Rightlastfind==1)) 
   1445              {
   1446                 for(i=Right-10;(i>=Right-50)&&(i>10);i--) ////////////////////////////////////////////////////////////////////////////////////////////???????????????????????????         
   1447                {
   1448                  if((CCD_Diff[i]>=CCD_Diff[i-1])&&(CCD_Diff[i]>CCD_Diff[i+1])&&(CCD_Diff[i]>threshold_t))  //寻找负的峰值
   1449                  {  
   1450                    Left=i;
   1451                    Leftlastfind=1;
   1452                    break;
   1453                  }
   1454                }
   1455              }
   1456              
   1457              if(Leftlastfind==0||Rightlastfind==0)  ////////////////////////////////////////////////////////////////////////////////////////////???????????????????????????????????
   1458              {
   1459                 if((Distance-Character_Distance)>3) 
   1460               {
   1461                 if(Is_Black_Line())
   1462                 {
   1463                    RoadType=4;
   1464                    Turn_To_Angle=0;//??????????????????????????????????
   1465                    Strong_Turn_Cnt=0;
   1466                    Strong_Turn_En=0;
   1467                    Turn_State=0;
   1468                    Turn_Angle_Integral=0;
   1469                 }
   1470               }
   1471                
   1472                lost_cnt++;
   1473                if(Right-Left>50||(lost_cnt>=3&&Right-Left>30)||(lost_cnt>=5&&Right-Left<20))
   1474                {
   1475                  RoadType=0;
   1476                  Confirm_Cnt=0;
   1477                  RoadTypeConfirm=0;
   1478                }
   1479              }
   1480              else lost_cnt=0;
   1481            }
   1482             if((Distance-Character_Distance)>3.3)   //假设坡道长度不超过3m
   1483               /*            跳回正常道路            */
   1484             {
   1485               Last_Hill_Distance=Distance;
   1486               RoadType=0;
   1487               Hill_Flag=1;
   1488               Confirm_Cnt=0;
   1489               RoadTypeConfirm=0;
   1490             }
   1491             
   1492          
   1493             
   1494          }
   1495          uint8 FindNearest(uint8 mode,uint8 lastegde)
   1496          {
   1497            uint8 find=0;
   1498            if(mode==left)
   1499            {
   1500               if(RisingEdgeCnt!=0)  
   1501               {
   1502                for(RisingEdgeIndex=0;RisingEdgeIndex<RisingEdgeCnt;RisingEdgeIndex++)
   1503                {
   1504                 if(ABS(lastegde-RisingEdge[RisingEdgeIndex])<=3)//3
   1505                 {
   1506                   find=1;
   1507                   break;
   1508                 }
   1509                }
   1510               }
   1511            }
   1512            else
   1513            {
   1514              if(FallingEdgeCnt!=0)  
   1515             {
   1516               for(FallingEdgeIndex=0;FallingEdgeIndex<FallingEdgeCnt;FallingEdgeIndex++)
   1517               {
   1518                 if(ABS(lastegde-FallingEdge[FallingEdgeIndex])<=3)//3
   1519                 {
   1520                   find=1;
   1521                   break;
   1522                 }
   1523               }
   1524             }
   1525            }
   1526            return find;
   1527          }
   1528          uint8 FindBoundary(uint8 mode)    //寻找最靠近中心的边界
   1529          {
   1530            uint8 find=0;
   1531            if(mode==left)
   1532            { 
   1533             if(RisingEdgeCnt!=0)  
   1534             { 
   1535              for(RisingEdgeIndex=RisingEdgeCnt-1;RisingEdgeIndex>=0;RisingEdgeIndex--)
   1536              {
   1537               if(RisingEdge[RisingEdgeIndex]<75)
   1538               {
   1539                 find=1;
   1540                 break;
   1541               }
   1542               if(RisingEdgeIndex==0)  break;
   1543              }
   1544             }
   1545            }
   1546             else
   1547            {
   1548              if(FallingEdgeCnt!=0)  
   1549              {
   1550               for(FallingEdgeIndex=0;FallingEdgeIndex<FallingEdgeCnt;FallingEdgeIndex++)
   1551               {
   1552                if(FallingEdge[FallingEdgeIndex]>53)
   1553                {
   1554                 find=1;
   1555                 break;
   1556                }
   1557               }
   1558              }
   1559            }
   1560            return find;
   1561          }
   1562          
   1563          //坡道检测
   1564          void Is_Hill()
   1565          {
   1566             static int Width_Increase_Cnt=0,Straight_Cnt; 
   1567             float slope;
   1568             float Angle_Change=0;
   1569             int i;
   1570             
   1571             Angle_Change = Previous_Angle[0]+Previous_Angle[1]+Previous_Angle[2]-Previous_Angle[3]-Previous_Angle[4]-Previous_Angle[5];
   1572             Angle_Change=Angle_Change/3;
   1573             
   1574             if((Stop==0)&&(Distance>1)&&(ABS(Middle_Err)<=3)&&(RoadType!=5)&&Rightlastfind&&Leftlastfind&&(Angle_Change>-1))    //偏差小于一定值 在直道，用于判定坡道。跑动距离大于0.5，再判断值，防止起跑误判
   1575             {
   1576                 Straight_Cnt++;
   1577                 if(Straight_Cnt>14)                //计算连续15次的值                             //前15个状态一直是直道
   1578                 {
   1579                    Width_Increase_Cnt=0;
   1580                  
   1581                    slope=10* Slope_Calculate(0,8,Previous_Error); 
   1582                              
   1583                    for(i=0;i<10;i++)                        
   1584                   {
   1585                     Width_Increase_Cnt+=Previous_Width[i]-Previous_Width[i+1];
   1586                   }
   1587                    
   1588                   if((Width_Increase_Cnt>=5)&&(ABS(slope)<2))      //只要宽度增加的次数大于5且变化的角度大于-3度则认为找打了坡道  排除由于车模角度减小带来的干扰
   1589                   {
   1590                     RoadType=5;
   1591                     RoadTypeConfirm=0;
   1592                     Character_Distance=Distance;
   1593                   } 
   1594                 }
   1595             }
   1596             else
   1597             {
   1598               Angle_Change=0;
   1599               Straight_Cnt=0;
   1600             }     
   1601          }
   1602          
   1603          void Is_Barraicade()
   1604          {
   1605            int left_edge,right_edge,left_edge_find,right_edge_find;
   1606            int i;
   1607            float half_width=0;
   1608            half_width=Previous_Width[0]/2;
   1609            if(Leftlastfind&&Rightlastfind)
   1610            {
   1611              right_edge_find=0;
   1612              left_edge_find=0;
   1613              if(FallingEdgeCnt>0)
   1614              {
   1615                for(i=0;i<FallingEdgeCnt;i++)
   1616                {
   1617                 if((FallingEdge[i]>Leftlast)&&(FallingEdge[i]+7<Rightlast)) 
   1618                 {
   1619                  left_edge=FallingEdge[i]; 
   1620                  left_edge_find=1;
   1621                  break;
   1622                 }
   1623                }
   1624              }  
   1625              if(RisingEdgeCnt>0)  
   1626             {
   1627              for(i=RisingEdgeCnt-1;i>=0;i--)
   1628              {
   1629                 if((RisingEdge[i]<Rightlast)&&(RisingEdge[i]-7>Leftlast)) 
   1630                 {
   1631                  right_edge=RisingEdge[i]; 
   1632                  right_edge_find=1;
   1633                  break;
   1634                 }
   1635              }
   1636             }
   1637             
   1638             if(right_edge_find&&left_edge_find)
   1639             {
   1640               if(((right_edge-left_edge)*1.0/Previous_Width[0])>0.2)  //大于宽度的1/5 本来是1/4
   1641               {
   1642                 RoadType=2;
   1643                 Turn_State_Cnt=0;        
   1644                 Turn_Angle_Integral=0;
   1645                 Turn_State=0;
   1646                 Character_Distance=Distance;  
   1647                 if(Rightlast-right_edge>half_width) Right_Or_Left=left; //左边出现了障碍
   1648                 if(left_edge-Leftlast>half_width)   Right_Or_Left=right;  //右边出现了障碍 
   1649               }
   1650             }
   1651             
   1652             else if(left_edge_find)
   1653             {
   1654               
   1655             }
   1656             else if(right_edge_find)
   1657             {
   1658               
   1659             }
   1660           }
   1661          }
   1662          
   1663          void Is_Straight_Angle_Turn()  
   1664          {
   1665            //斜着入直角，能搜到两条边线的变量
   1666            
   1667            static int Width_Change_Cnt_L=0,Width_Old_R;
   1668            static int Pre_Width_All_L=0;
   1669            int Width_All_L,Width_Low_L;
   1670            
   1671            static int Width_Change_Cnt_R=0,Width_Old_L;
   1672            static int Pre_Width_All_R=0;
   1673            int Width_All_R,Width_Low_R;
   1674          
   1675            
   1676            uint8 find=0; 
   1677            Turn_To_Angle=0;
   1678            //斜着入直角，不能搜到两条边线的变量
   1679            int i=0;
   1680            static uint8  leftfind_t=0,rightfind_t=0;
   1681            static uint8  leftlostcnt=0,rightlostcnt=0;
   1682          
   1683            
   1684            /*********************两边都找到线了*******************/
   1685           if(Leftlastfind&&Rightlastfind&&(Right-Left<60)&&(RoadTypeSwitch&8))  //两边都找到线了并且有斜着入直角
   1686            {
   1687              if((RisingEdgeIndex<RisingEdgeCnt-1)&&(RisingEdge[RisingEdgeIndex+1]<120))  //边线右边有多的上升沿
   1688              {
   1689                Width_All_R=RisingEdge[RisingEdgeIndex+1]-Left;
   1690                Width_Low_R=RisingEdge[RisingEdgeIndex+1]-Right;
   1691                if((Pre_Width_All_R>Width_All_R)&&(Width_Low_R<30)&&(Width_Low_R>=6))//Left-Line_Out>8
   1692                {
   1693                  if(Width_Change_Cnt_R==0) Width_Old_R=Right-Left;
   1694                  Width_Change_Cnt_R++;
   1695                  if(Width_Change_Cnt_R>=5)
   1696                  {
   1697                    if(Width_Old_R-(Right-Left)>5)
   1698                    {
   1699                      if(FallingEdgeIndex<FallingEdgeCnt-1)
   1700                      {
   1701                         Right=FallingEdge[FallingEdgeIndex+1];
   1702                         Rightlastfind=1;
   1703                      }
   1704                      
   1705                      else 
   1706                      {
   1707                        Right=126;
   1708                        Reference_Width= Right-Left;
   1709                        Rightlastfind=0;
   1710                      }  
   1711                      find=1;
   1712                      Turn_To_Angle=1;
   1713                      Width_Change_Cnt_R=0;
   1714                    }
   1715                  }
   1716                }
   1717                else 
   1718                {
   1719                  Width_Change_Cnt_R=0;
   1720                }
   1721                Pre_Width_All_R=Width_All_R;
   1722              }
   1723              
   1724              if((FallingEdgeIndex>=1)&&(FallingEdge[FallingEdgeIndex-1]>10))   //边线左边有多的下降沿
   1725              {
   1726                Width_All_L=Right-FallingEdge[FallingEdgeIndex-1];
   1727                Width_Low_L=Left-FallingEdge[FallingEdgeIndex-1];
   1728                if((Pre_Width_All_L>Width_All_L)&&(Width_Low_L<30)&&(Width_Low_L>=6))        //Left-Line_Out>8
   1729                {
   1730                  if(Width_Change_Cnt_L==0) Width_Old_L=Right-Left;
   1731                  Width_Change_Cnt_L++;
   1732                  if(Width_Change_Cnt_L>=5)
   1733                  {
   1734                    if(Width_Old_L-(Right-Left)>5)
   1735                    {
   1736                      if(RisingEdgeIndex>=1)
   1737                      {
   1738                         Left=RisingEdge[RisingEdgeIndex-1]; 
   1739                         Leftlastfind=1;
   1740                      }
   1741                      else 
   1742                      {
   1743                        Left=10;
   1744                        Reference_Width= Right-Left;
   1745                        Leftlastfind=0;
   1746                      }     
   1747                      find=1;
   1748                      Turn_To_Angle=-1;
   1749                      Width_Change_Cnt_L=0;
   1750                    }
   1751                  }
   1752                }
   1753                else
   1754                {
   1755                  Width_Change_Cnt_L=0;
   1756                }
   1757                Pre_Width_All_L= Width_All_L;
   1758              }
   1759            }
   1760            /**********************至少有一边能找到***********************/
   1761            else if((Leftlastfind||Rightlastfind)&&(Right-Left<55)&&(Right<110)&&(Left>18))  //有误判啊啊
   1762            {
   1763              if(Leftlastfind==0)
   1764              {
   1765                if(leftfind_t==0&&leftlostcnt<6)
   1766                {
   1767                    for(i=Left;i<Right;i++)
   1768                   {
   1769                     if(CCD_Draw_Buff[i]>60)//亮度的一半
   1770                     break;
   1771                   }
   1772                   if(i>Left+10&&i+10<Right)
   1773                   {
   1774                    if(ABS(i-Left)>10)  //与上次的差值
   1775                    find=1;  
   1776                   }
   1777                }
   1778              }
   1779               if(Rightlastfind==0)
   1780              {
   1781                if(rightfind_t==0&&rightlostcnt<6)
   1782                {
   1783                    for(i=Right;i>Left;i--)
   1784                   {
   1785                     if(CCD_Draw_Buff[i]>60)//亮度的一半
   1786                     break;
   1787                   }
   1788                   if(i>Left+10&&i+10<Right)
   1789                   {
   1790                    if(ABS(i-Right)>10)  //与上次的差值
   1791                    find=1;  
   1792                   }
   1793                }
   1794              }
   1795              
   1796            }
   1797           
   1798           
   1799           if(Leftlastfind==0&&Rightlastfind==0)
   1800           {
   1801             if(Is_Black_Line())
   1802             {
   1803              RoadType=4;
   1804              Strong_Turn_Cnt=0;
   1805              Turn_To_Angle=0;
   1806              Turn_Angle_Integral=0;
   1807              Strong_Turn_En=0;
   1808              Turn_State=0;  
   1809              Character_Distance=Distance;
   1810             }
   1811           }
   1812           
   1813           //////////////////////
   1814            if(find==1)   //找到是直角了
   1815            {
   1816              RoadType=4;
   1817              Strong_Turn_Cnt=0;
   1818              Strong_Turn_En=0;
   1819              Turn_Angle_Integral=0;
   1820              Turn_State=0;  
   1821              Character_Distance=Distance;
   1822            }
   1823            leftfind_t=Leftlastfind;
   1824            rightfind_t=Rightlastfind;
   1825            if(leftfind_t==0)
   1826            {
   1827              if(leftlostcnt<10)
   1828                leftlostcnt++;
   1829            }
   1830            else leftlostcnt=0;
   1831            
   1832            if(rightfind_t==0)
   1833            {
   1834               if(rightlostcnt<10) 
   1835               rightlostcnt++;
   1836            }
   1837            else rightlostcnt=0;
   1838            
   1839            
   1840             if(ABS(Middle_Err)<5&&(Last_Angle_Turn_Position>2)&&(Distance-Last_Angle_Turn_Position<1.2)&&(Distance-Last_Angle_Turn_Position>0.7)&&(RoadTypeSwitch&1))//
   1841            {
   1842             if(((Leftlastfind&&Rightlastfind)==0)&&(Leftlastfind||Rightlastfind))
   1843             {
   1844               Character_Distance=Distance-1;
   1845              
   1846               state_change=0;
   1847               
   1848                RoadType=4;
   1849                Turn_State=1;  
   1850                Refind_Cnt=0;
   1851                Strong_Turn_En=1;
   1852                Strong_Turn_Cnt=0;
   1853                Turn_Angle_Integral=0;
   1854                
   1855                Turn_State1To2_Left=Left;
   1856                Turn_State1To2_Right=Right;
   1857               
   1858                if(Leftlastfind==0)
   1859                {
   1860                  Right_Or_Left=1; //左直角 
   1861                }
   1862                else  Right_Or_Left=-1; //右直角 
   1863             }  
   1864            }  
   1865          }
   1866          
   1867          void Is_CrossRoad(void)  //斜入十字   //深色背景适用！
   1868          {
   1869             static int Width_Change_Cnt_L;
   1870             static int Pre_Width_Out_L,Pre_Width_All_L;
   1871             int Width_Out_L,Line_Out_L,Width_All_L;
   1872            
   1873             static int Width_Change_Cnt_R;
   1874             static int Pre_Width_Out_R,Pre_Width_All_R;        
   1875             int Width_Out_R,Line_Out_R,Width_All_R;
   1876             
   1877             static uint8 All_Find=0;
   1878             
   1879             if(Leftlastfind&&Rightlastfind)  //两边都找到线了
   1880            {
   1881              if((RisingEdgeIndex<RisingEdgeCnt-1)&&(RoadTypeSwitch&4))                //右边有多的上升沿
   1882              { 
   1883                Line_Out_R=RisingEdge[RisingEdgeIndex+1];
   1884                Width_Out_R=Line_Out_R-Right;
   1885                Width_All_R=Line_Out_R-Left;
   1886                if(Width_Out_R<6)  //白色背景
   1887                {
   1888                  if(RisingEdgeIndex<RisingEdgeCnt-2)  
   1889                  {
   1890                    Line_Out_R=RisingEdge[RisingEdgeIndex+2];
   1891                    Width_Out_R=Line_Out_R-Right;
   1892                    Width_All_R=Line_Out_R-Left;
   1893                  }
   1894                }
   1895                if(Width_Out_R>8)
   1896                {  
   1897                  if((Pre_Width_Out_R>Width_Out_R)&&(Width_All_R<=Pre_Width_All_R))  //
   1898                  {
   1899                     Width_Change_Cnt_R++;
   1900                  }
   1901                  else  Width_Change_Cnt_R=0;
   1902                }
   1903                Pre_Width_Out_R= Width_Out_R;
   1904                Pre_Width_All_R= Width_All_R;
   1905              }
   1906              else 
   1907              {
   1908                Width_Change_Cnt_R=0;
   1909              }
   1910              
   1911              if((FallingEdgeIndex>=1)&&(RoadTypeSwitch&4))    //左边有多的下降沿 
   1912              {
   1913                Line_Out_L=FallingEdge[FallingEdgeIndex-1];
   1914                Width_Out_L=Left-Line_Out_L;
   1915                Width_All_L=Right-Line_Out_L;
   1916                if(Width_Out_L<6)  //白色背景
   1917                {
   1918                  if(FallingEdgeIndex>=2)  //白色背景
   1919                  {
   1920                   Line_Out_L=FallingEdge[FallingEdgeIndex-2];
   1921                   Width_Out_L=Left-Line_Out_L;
   1922                   Width_All_L=Right-Line_Out_L;
   1923                  }
   1924                }
   1925                if(Width_Out_L>8)
   1926                {  
   1927                  if((Pre_Width_Out_L>Width_Out_L)&&(Pre_Width_All_L>=Width_All_L))  //
   1928                  {
   1929                     Width_Change_Cnt_L++;
   1930                  }
   1931                  else  Width_Change_Cnt_L=0;
   1932                }
   1933                Pre_Width_Out_L= Width_Out_L;
   1934                Pre_Width_All_L= Width_All_L;
   1935              }
   1936              else
   1937              {
   1938                Width_Change_Cnt_L=0;
   1939              }
   1940              All_Find=1;
   1941             }
   1942             else                       
   1943             {    
   1944               if(Width_Change_Cnt_R>=5||Width_Change_Cnt_L>=5)
   1945               {
   1946                if(RoadTypeSwitch&4) curve_to_cross=1;
   1947                 RoadType=1; 
   1948                 Character_Distance=Distance;
   1949               }
   1950               if(All_Find==1)          
   1951               { 
   1952                 Width_Change_Cnt_L=0;
   1953                 Width_Change_Cnt_R=0;
   1954               }  
   1955               else 
   1956               {
   1957                if(Leftlastfind&&(Left<60))
   1958                {
   1959                   if((FallingEdgeCnt==0)||FallingEdge[FallingEdgeCnt-1]<Left)  //右边没有多的线了
   1960                  {
   1961                    if(Left<Leftlast) Width_Change_Cnt_L++;         
   1962                    else  Width_Change_Cnt_L=0;
   1963                  }
   1964                  else Width_Change_Cnt_L=0;
   1965                }
   1966                if(Rightlastfind&&(Right>70))
   1967                {
   1968                  if((RisingEdgeCnt==0)||RisingEdge[0]>Right)  //左边没有多的线了
   1969                  {
   1970                    if(Right>Rightlast)    Width_Change_Cnt_R++;
   1971                    else  Width_Change_Cnt_R=0;
   1972                  }
   1973                  else Width_Change_Cnt_R=0;
   1974                }
   1975               }
   1976               All_Find=0;
   1977             }  
   1978          }
   1979          void Is_Single_Line()
   1980          {
   1981            uint8 i=0,j=0,threshold=45;
   1982            uint8 find=0;
   1983            
   1984            uint8 Single_Line_Detected=0;
   1985            
   1986            static int Width_Change_Cnt;
   1987            static int Pre_Width_In,Preine_Out;
   1988            int Width_In,Line_Out;
   1989            
   1990            static int Width_Change_Cnt_R;
   1991            static int Pre_Width_In_R,Preine_Out_R;
   1992            int Width_In_R,Line_Out_R;
   1993            
   1994            static int Single_Line_Cnt=0;
   1995            
   1996            
   1997            Single_Line_Detected=0;
   1998            
   1999            
   2000             if(Leftlastfind&&Rightlastfind&&Single_Out_Detect&&(RoadTypeSwitch&2))  //两边都找到线了并且有斜入单线
   2001            {
   2002              if((RisingEdgeIndex<RisingEdgeCnt-1)&&(Middle_Err<-12))  //右弯入单线
   2003              {
   2004                Width_In_R=Right-Left;
   2005                Line_Out_R=RisingEdge[RisingEdgeIndex+1];
   2006                if((Pre_Width_In_R>Width_In_R)&&(Line_Out_R<=Preine_Out_R)&&(Line_Out_R-Right<=6)&&Width_In_R<45)
   2007                {
   2008                  if(ABS(CCD_Buff[Line_Out_R+3]-CCD_Buff[Right-3])<25)
   2009                  Width_Change_Cnt_R++;
   2010                  if(Width_Change_Cnt_R>=4)//4
   2011                  {
   2012                      find=1;
   2013                      i=Right;
   2014                      j=Line_Out_R;
   2015                  }
   2016                }
   2017                else 
   2018                { 
   2019                  if((Pre_Width_In_R==Width_In_R)&&(Line_Out_R<=Preine_Out_R)&&(Line_Out_R-Right<=6)&&Width_In_R<45)
   2020                  Width_Change_Cnt_R=Width_Change_Cnt_R-1;
   2021                  else Width_Change_Cnt_R=0;
   2022                }
   2023                Pre_Width_In_R= Width_In_R;
   2024                Preine_Out_R=Line_Out_R;
   2025              }
   2026              
   2027              if((FallingEdgeIndex>=1)&&(Middle_Err>12))  //左弯入单线
   2028              {
   2029                Width_In=Right-Left;
   2030                Line_Out=FallingEdge[FallingEdgeIndex-1];
   2031                 if((Pre_Width_In>Width_In)&&(Line_Out>=Preine_Out)&&(Left-Line_Out<=6)&&Width_In<45)
   2032                {
   2033                  if(ABS(CCD_Buff[Line_Out-3]-CCD_Buff[Left+2])<25)
   2034                  Width_Change_Cnt++;
   2035                  if(Width_Change_Cnt>=4)//4
   2036                  {
   2037                      find=1;
   2038                      i=Line_Out;
   2039                      j=Left;
   2040                  }
   2041                }   
   2042                else 
   2043                {
   2044                  if((Pre_Width_In==Width_In)&&(Line_Out>=Preine_Out)&&(Left-Line_Out<=6)&&Width_In<45)
   2045                  Width_Change_Cnt=Width_Change_Cnt-1;
   2046                  else Width_Change_Cnt=0;
   2047                }
   2048                Pre_Width_In=Width_In;
   2049                Preine_Out=Line_Out;
   2050              }
   2051            }
   2052            
   2053            
   2054           if(Single_Out_Detect==0)
   2055           { 
   2056            for(i=10;i<116;i++)         
   2057            {
   2058              if((CCD_Diff[i]<CCD_Diff[i-1])&&(CCD_Diff[i]<=CCD_Diff[i+1])&&(CCD_Diff[i]<-threshold))  //寻找负的峰值
   2059              {
   2060                for(j=i+2;j<=i+10;j++) 
   2061                {
   2062                  if((CCD_Diff[j]>=CCD_Diff[j-1])&&(CCD_Diff[j]>CCD_Diff[j+1])&&(CCD_Diff[j]>threshold)) //寻找正的峰值
   2063                  { 
   2064                    if(ABS(CCD_Diff[i]+CCD_Diff[j])<30)  //峰值的绝对差小于一定值
   2065                    {
   2066                      
   2067                         if(Leftlastfind&&Rightlastfind)  //情况一，上次两边都找到了线
   2068                         {
   2069                           if((i>Left+10)&&(j+10<Right))
   2070                           {
   2071                              find=1;
   2072                           }
   2073                         }
   2074                          if(Leftlastfind&&Rightlastfind==0)  //情况二，上次只有一边找到线
   2075                         {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
   2076                           if((i-Left>10)&&(i-Left<40))
   2077                           {
   2078                              find=1;
   2079                           }
   2080                         }
   2081                          if(Leftlastfind==0&&Rightlastfind)  //情况三，上次只有一边找到线了
   2082                         {
   2083                              if((Right-j>10)&&(Right-j<40))
   2084                             {
   2085                                find=1;
   2086                             }
   2087                         }
   2088                         if(Leftlastfind==0&&Rightlastfind==0)  //情况四，上次两边都没找到线
   2089                         {
   2090               
   2091                              find=1;
   2092                         }
   2093                        
   2094                        Single_Line_Detected=1;
   2095                         
   2096                    }
   2097                    break;
   2098                  }
   2099                }
   2100              }
   2101              if(find) break;
   2102             }
   2103            
   2104            
   2105            
   2106              if((find==0)&&(Single_Line_Detected)&&(RoadTypeSwitch&2)&&((i-j)<=5))       //情况五，明显是单线
   2107             {
   2108               Single_Line_Cnt++;
   2109               if(Single_Line_Cnt>3)
   2110               { 
   2111                 Single_Line_Cnt=0;
   2112                 find=1;
   2113               }
   2114             }
   2115             else  Single_Line_Cnt=0; 
   2116            
   2117            }
   2118            
   2119            
   2120                if(find)
   2121              {
   2122                 Single_Line_Cnt=0;
   2123                 Left=i;
   2124                 Right=j;
   2125                 RoadType=3;
   2126                 Leftlastfind=1;
   2127                 Rightlastfind=1;
   2128                 Character_Distance=Distance;
   2129              }
   2130             
   2131             
   2132          }
   2133          void Brightness_Calculate()   //计算赛道中心亮度
   2134          {
   2135            uint8 i;
   2136            uint32 tempi=0;
   2137            float tempf=0;
   2138            for(i=Left;i<=Right;i++)
   2139            {
   2140              tempi+=CCD_Buff[i];
   2141            }
   2142            tempf=tempi*1.0/(Right-Left);
   2143            
   2144            tempf=tempf*(Max_Value-CCD_Offset)/127.0+CCD_Offset;
   2145            Brightness=(int)(Brightness*0.95+tempf*0.05);
   2146            CCD_Draw_Buff[140]=BYTE0(Brightness);
   2147            CCD_Draw_Buff[141]=BYTE1(Brightness);  
   2148          }
   2149          void Find_Bothine()
   2150          {
   2151              uint8 i=0,j=0,find=0;
   2152              for(j=60;j>20;j--)
   2153              {
   2154                 if((CCD_Diff[j]>=CCD_Diff[j-1])&&(CCD_Diff[j]>CCD_Diff[j+1])&&(CCD_Diff[j]>Threshold)) //寻找正的峰值
   2155                {
   2156                 break;
   2157                }
   2158              }
   2159               for(i=70;i<110;i++)
   2160               {
   2161                  if((CCD_Diff[i]<CCD_Diff[i-1])&&(CCD_Diff[i]<=CCD_Diff[i+1])&&(CCD_Diff[i]<-Threshold))  //寻找负的峰值
   2162                  {
   2163                    break;
   2164                  }
   2165               }
   2166              if(j>25&&i<105)
   2167              {
   2168                find=1;
   2169                 Left=j;
   2170                 Right=i;
   2171                 Leftlastfind=1;
   2172                 Rightlastfind=1;  
   2173              }
   2174              else
   2175              {    
   2176                for(j=10;j<80;j++)         
   2177                {
   2178                   if((CCD_Diff[j]>=CCD_Diff[j-1])&&(CCD_Diff[j]>CCD_Diff[j+1])&&(CCD_Diff[j]>Threshold)) //寻找正的峰值
   2179                  {
   2180                    for(i=j+1;i<=120;i++) 
   2181                    {
   2182                      if((CCD_Diff[i]<CCD_Diff[i-1])&&(CCD_Diff[i]<=CCD_Diff[i+1])&&(CCD_Diff[i]<-Threshold))  //寻找负的峰值
   2183                      {
   2184                        if(i-j>25)
   2185                        {
   2186                           find=1;
   2187                           Left=j;
   2188                           Right=i;
   2189                           Leftlastfind=1;
   2190                           Rightlastfind=1; 
   2191                        }
   2192                        break;
   2193                      }
   2194                    }
   2195                  }
   2196                  if(find) break;
   2197                } 
   2198              }
   2199              if(find==0)
   2200              {
   2201                Leftlastfind=0;
   2202                Rightlastfind=0; 
   2203              }
   2204          }
   2205          uint8 Is_Black_Line()
   2206          {
   2207            uint8 i,j=0;
   2208            uint32 tempi=0;
   2209            float tempf=0;
   2210            for(i=54;i<74;i++)  //计算中间几个点的亮度值
   2211            {
   2212             if(CCD_Buff[i]>10)  tempi+=CCD_Buff[i];
   2213            }
   2214            tempf=tempi*1.0/20;
   2215            
   2216            tempi=(int)(tempf*(Max_Value-CCD_Offset)/127.0+CCD_Offset);
   2217            
   2218            if(tempi<Brightness/2)
   2219            {
   2220              j=1;
   2221            }
   2222            else j=0;
   2223            return j;
   2224          }
   2225          void Push_And_Pull(float *buff,int len,float newdata)
   2226          {
   2227           int i;
   2228           for(i=len-1;i>0;i--)
   2229           {
   2230             *(buff+i)=*(buff+i-1);
   2231           }
   2232             *buff=newdata; 
   2233          }

Errors: 2
Warnings: 20
